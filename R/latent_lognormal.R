#' Draws from the posterior predictive distribution of the `latent_lognormal`
#' family
#'
#' See [brms::posterior_predict()].
#'
#' @param i The index of the observation to predict
#' @param prep The result of a call to [brms::posterior_predict()]
#' @param ... Additional arguments
#' @autoglobal
#' @keywords internal
posterior_predict_latent_lognormal <- function(i, prep, ...) { # nolint: object_length_linter
  mu <- brms::get_dpar(prep, "mu", i = i)
  sigma <- brms::get_dpar(prep, "sigma", i = i)

  relative_obs_time <- prep$data$vreal1[i]
  pwindow <- prep$data$vreal2[i]
  swindow <- prep$data$vreal3[i]

  .predict <- function(s) {
    d_censored <- relative_obs_time + 1
    # while loop to impose the truncation
    while (d_censored > relative_obs_time) {
      p_latent <- stats::runif(1, 0, 1) * pwindow
      d_latent <- stats::rlnorm(1, meanlog = mu[s], sdlog = sigma[s])
      s_latent <- p_latent + d_latent
      p_censored <- .floor_mult(p_latent, pwindow)
      s_censored <- .floor_mult(s_latent, swindow)
      d_censored <- s_censored - p_censored
    }
    return(d_censored)
  }

  # Within brms this is a helper function called rblapply
  do.call(rbind, lapply(seq_len(prep$ndraws), .predict))
}

#' Draws from the expected value of the posterior predictive distribution of the
#' `latent_gamma` family
#'
#' See [brms::posterior_epred()].
#'
#' @param prep The result of a call to [`brms::prepare_predictions`]
#' @autoglobal
#' @keywords internal
posterior_epred_latent_lognormal <- function(prep) { # nolint: object_length_linter
  mu <- brms::get_dpar(prep, "mu")
  sigma <- brms::get_dpar(prep, "sigma")
  exp(mu + sigma^2 / 2)
}

#' Calculate the pointwise log likelihood of the `latent_gamma` family
#'
#' See [brms::log_lik()].
#'
#' @param i The index of the observation to calculate the log likelihood of
#' @param prep The result of a call to [brms::prepare_predictions()]
#' @autoglobal
#' @keywords internal
log_lik_latent_lognormal <- function(i, prep) {
  mu <- brms::get_dpar(prep, "mu", i = i)
  sigma <- brms::get_dpar(prep, "sigma", i = i)
  y <- prep$data$Y[i]
  relative_obs_time <- prep$data$vreal1[i]
  pwindow <- prep$data$vreal2[i]
  swindow <- prep$data$vreal3[i]

  # Generates values of the swindow_raw and pwindow_raw, but really these should
  # be extracted from prep or the fitted raws somehow. See:
  # https://github.com/epinowcast/epidist/issues/267
  swindow_raw <- stats::runif(prep$ndraws)
  pwindow_raw <- stats::runif(prep$ndraws)

  swindow <- swindow_raw * swindow

  # For no overlap calculate as usual, for overlap ensure pwindow < swindow
  if (i %in% prep$data$noverlap) {
    pwindow <- pwindow_raw * pwindow
  } else {
    pwindow <- pwindow_raw * swindow
  }

  d <- y - pwindow + swindow
  obs_time <- relative_obs_time - pwindow
  lpdf <- stats::dlnorm(d, meanlog = mu, sdlog = sigma, log = TRUE)
  lcdf <- stats::plnorm(obs_time, meanlog = mu, sdlog = sigma, log.p = TRUE)
  return(lpdf - lcdf)
}
