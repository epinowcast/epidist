---
output: github_document
---

# Adjusting for common biases in infectious disease data when estimating distributions.


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "figures/README-",
  out.width = "100%",
  dpi = 330,
  message = FALSE, warning = FALSE
)
```

## A simple example

First load required packages and functions.

```{r load-requirements}
library(data.table)
library(purrr, quietly = TRUE)
library(here)
library(brms)
functions <- list.files(here("R"), full.names = TRUE)
walk(functions, source)
```

Now simulate data from an outbreak.
```{r simulate-outbreak}
outbreak <- simulate_gillespie(seed=101)
```


Simulate an observation process during the growth phase for a secondary event using a lognormal distribution, and finally simulate observing this event.

```{r simulate-data}
truncated_obs <- outbreak |>
  simulate_secondary(
    meanlog = 1.8,
    sdlog = 0.3
  ) |>
  observe_process() |>
  filter_obs_by_obs_time(obs_time = 20)
```

First fit a naive lognormal model with no adjustment.

```{r}
naive_fit <- naive_delay(data = truncated_obs, cores = 4, refresh = 0)
summary(naive_fit)
```

Adjust for date censoring.

```{r}
censored_fit <- censoring_adjusted_delay(
  data = truncated_obs, cores = 4, refresh = 0
)
summary(censored_fit)
```

Adjust for right truncation.

```{r}
truncation_fit <- truncation_adjusted_delay(
  data = truncated_obs, cores = 4, refresh = 0
)
summary(truncation_fit)
```


Adjust for right truncation and date censoring.

```{r}
truncation_censoring_fit <- truncation_censoring_adjusted_delay(
  data = truncated_obs, cores = 4, refresh = 0
)
summary(truncation_censoring_fit)
```

Adjust for right truncation and date censoring using a latent variable approach.

```{r}
latent_truncation_censoring_fit <- latent_truncation_censoring_adjusted_delay(
  data = truncated_obs, cores = 4, refresh = 0, fn = brms::make_stancode
)
summary(latent_truncation_censoring_fit)
```


## Analyses

This analysis in this repository has been implemented using the [`targets`](https://docs.ropensci.org/targets/) package and associated packages. The workflow is defined in [`_targets.md`](https://github.com/parksw3/dynamicaltruncation/blob/main/_targets.md) and can be explored interactively using [`_targets.Rmd`](https://github.com/parksw3/dynamicaltruncation/blob/main/_targets.Rmd) `Rmarkdown` document. The workflow can be visualised as the following graph.


This complete analysis can be recreated using the following (note this may take quite some time even with a fairly large amount of available compute),

```{bash}
bash bin/update-targets.sh
```

Alternative the following `targets` functions may be used to interactively explore the workflow:

- Run the workflow sequentially.

```{r, eval = FALSE}
targets::tar_make()
```

- Run the workflow using all available workers.

```{r, eval = FALSE}
targets::tar_make_future(workers = future::availableCores())
```

- Explore a graph of the workflow.

```{r, eval = FALSE}
targets::tar_visnetwork(targets_only = TRUE)
```

Watch the workflow as it runs in a `shiny` app.

```{r, eval = FALSE}
targets::tar_watch(targets_only = TRUE)
```

To use our archived version of the interim results (and so avoid long run times) use the following to download it. Note that this process has not been rigorously tested across environments and so may not work seamlessly).

```{r, eval = FALSE}
source(here::here("R", "targets-archive.R"))
get_targets_archive()
```