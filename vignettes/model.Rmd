---
title: "A guide to the `epidist` model"
description: "..."
output: 
  bookdown::html_document2:
    fig_caption: yes
    code_folding: show
    number_sections: true
pkgdown:
  as_is: true
# csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-numeric-superscript-brackets.csl
link-citations: true
vignette: >
  %\VignetteIndexEntry{Getting started with epidist}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: references.bib
---

```{r setup, include=FALSE}
# exclude compile warnings from cmdstanr
knitr::opts_chunk$set(
  fig.path = "figures/epidist-",
  cache = TRUE,
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE,
  error = FALSE
)
```

```{r load-requirements}
library(epidist)
library(data.table)
library(purrr)
library(ggplot2)
```

# Maths

Let $p$ be time of primary event with rate (incidence) $\mathcal{P}(p)$.
Let $s$ be time of secondary event with rate (incidence) $\mathcal{S}(s)$.
Let $f_p(\tau)$ be probability of delay $\tau$ after observing primary event at time $p$ such that $p + \tau = s$.
Let $b_s(\tau)$ be probability of delay $\tau$ after observing secondary event at time $s$.
Let $\mathcal{T}(p, s)$ be density of individuals with primary event at time $p$ and secondary event at time $s$.
Then forwards
$$
\mathcal{T}(p, s) = \mathcal{P}(p) f_p(s - p),
$$
and backwards
$$
\mathcal{T}(p, s) = \mathcal{S}(s) b_s(s - p).
$$
Therefore by equivalence of forwards and backwards
$$
\mathcal{P}(p) f_p(s - p) = \mathcal{S}(s) b_s(s - p).
$$
Rearranging gives
$$
b_s(\tau) = \frac{\mathcal{P}(s - \tau) f_{s - \tau}(\tau)}{\mathcal{S}(s)}.
$$
The denominator may be expressed as the integral over all possible delays
$$
\mathcal{S}(s) = \int_{-\infty}^\infty \mathcal{P}(s - \tau) f_{s - \tau}(\tau) \text{d} \tau.
$$

## Correct thing

Let $\mathbf{Y}$ be the data vector and $\boldsymbol{\theta}$ be parameters.
Then
$$ 
\mathcal{L}(\mathbf{Y} \, | \, \boldsymbol{\theta}) = \prod_i \mathbb{P}(S_{L, i} < S < S_{R, i} \, | \, P_{L, i} < P < P_{R, i}, S < T).
$$

<!-- Shouldn't this be a joint likelihood? -->

Equivalent latent variable approach
\begin{align}
x_i &\sim g_P(x_i \, | \, p_{L, i}, p_{R, i}) \\
y_i &\sim \text{Unif}(s_{L, i}, s_{R, i}) \\
\mathcal{L}(\mathbf{Y} \, | \, \boldsymbol{\theta}) &= \prod_i \left[ \frac{f_\text{forward}(y_i - x_i)}{\int_{P_{L, i}}^{P_{R, i}} g_P(z \, | \, p_{L, i}, p_{R, i}) F_\text{forward}(T - z) \text{d}z} \right].
\end{align}

Modelling $g_P$ $\iff$ modelling incidence in primary events.
This is a tough thing to do.

## Approximate thing that we do

**Assume primary event incidence constant** leads to
\begin{align}
x_i &\sim \text{Unif}(p_{L, i}, p_{R, i}) \\
y_i &\sim \text{Unif}(s_{L, i}, s_{R, i}).
\end{align}
Further, assume that censoring interval is narrow such that
$$
\int_{P_{L, i}}^{P_{R, i}} g_P(z \, | \, p_{L, i}, p_{R, i}) F_\text{forward}(T - z) \text{d}z \approx F_\text{forward}(T - x_i),
$$
then
$$
\mathcal{L}(\mathbf{Y}_i \, | \, \boldsymbol{\theta}) = \frac{f_\text{forward}(y_i - x_i)}{F_\text{forward}(T - x_i)}.
$$
This is the approach of `latent_truncation_censoring_adjusted_delay` and that of @ward2022transmission.

# Implementation

```{r}
meanlog <- 1.8
sdlog <- 0.5
obs_time <- 25
sample_size <- 200

obs_cens_trunc <- simulate_gillespie() |>
  simulate_secondary(
    meanlog = meanlog,
    sdlog = sdlog
  ) |>
  observe_process() |>
  filter_obs_by_obs_time(obs_time = obs_time)

obs_cens_trunc_samp <- obs_cens_trunc[sample(seq_len(.N), sample_size, replace = FALSE)]

data <- obs_cens_trunc_samp
```

* How it is implemented in the package
* What the extra arguments of the function do, if you'd like to change them
* Which parts of the arguments we would imagine you might want to change and the potential use-cases

The equation `brms::bf` defines a model for the two parameters, `delay_central` and `sigma`, of the response distribution:

```{r}
formula <- brms::bf(delay_central | vreal(obs_t, pwindow_upr, swindow_upr) ~ 1, sigma ~ 1)
```

```{r}
fn <- brms::brm
```

```{r}
family <- brms::custom_family(
  "latent_lognormal",
  dpars = c("mu", "sigma"),
  links = c("identity", "log"),
  lb = c(NA, 0),
  ub = c(NA, NA),
  type = "real",
  vars = c("pwindow", "swindow", "vreal1"),
  loop = FALSE
)

scode_functions <-
  "\n real latent_lognormal_lpdf(vector y, vector mu, vector sigma,
   \n vector pwindow, vector swindow,
   \n array[] real obs_t) {
   \n      int n = num_elements(y);
   \n      vector[n] d = y - pwindow + swindow;
   \n      vector[n] obs_time = to_vector(obs_t) - pwindow;
   \n      return lognormal_lpdf(d | mu, sigma) -
   \n        lognormal_lcdf(obs_time | mu, sigma);
   \n      }
   \n"

scode_parameters <-
  "\n    vector<lower = 0, upper = 1>[N] swindow_raw;
   \n    vector<lower = 0, upper = 1>[N] pwindow_raw;
   \n"

scode_tparameters <-
  "\n    vector<lower = 0>[N] pwindow;\n    vector<lower = 0>[N] swindow;
   \n    swindow = to_vector(vreal3) .* swindow_raw;
   \n    pwindow[noverlap] = to_vector(vreal2[noverlap]) .* pwindow_raw[noverlap];
   \n    if (wN) {
   \n      pwindow[woverlap] = swindow[woverlap] .* pwindow_raw[woverlap];
   \n    }
   \n"

scode_priors <-
  "\n    swindow_raw ~ uniform(0, 1);
   \n    pwindow_raw ~ uniform(0, 1);
   \n"
```


```{r}
data <- data.table::as.data.table(data)
data[, id := 1:.N]
data[, obs_t := obs_at - ptime_lwr]

data[, pwindow_upr := ifelse(
  stime_lwr < ptime_upr, ## if overlap
  stime_upr - ptime_lwr,
  ptime_upr - ptime_lwr
)]

data[, woverlap := as.numeric(stime_lwr < ptime_upr)]
data[, swindow_upr := stime_upr - stime_lwr]
data[, delay_central := stime_lwr - ptime_lwr]
data[, row_id := 1:.N]

if (nrow(data) > 1) {
  data <- data[, id := as.factor(id)]
}

stanvars_functions <- brms::stanvar(
  block = "functions", scode = scode_functions
)

stanvars_data <- brms::stanvar(
  block = "data", scode = "int wN;",
  x = nrow(data[woverlap > 0]),
  name = "wN"
) +

brms::stanvar(
  block = "data", scode = "array[N - wN] int noverlap;",
  x = data[woverlap == 0][, row_id],
  name = "noverlap"
) +
brms::stanvar(
  block = "data", scode = "array[wN] int woverlap;",
  x = data[woverlap > 0][, row_id],
  name = "woverlap"
)

stanvars_parameters <- brms::stanvar(
  block = "parameters", scode = scode_parameters
)

stanvars_tparameters <- brms::stanvar(
  block = "tparameters", scode = scode_tparameters
)

stanvars_priors <- brms::stanvar(block = "model", scode = scode_priors)

stanvars_all <- stanvars_functions + stanvars_data + stanvars_parameters + 
  stanvars_tparameters + stanvars_priors

fit <- fn(
  formula = formula, family = family, stanvars = stanvars_all,
  backend = "cmdstanr", data = data
)
```

* The limitations of the model (ways it's not ideal)

## Bibliography {-}
