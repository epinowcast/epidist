---
title: "Approximate Bayesian inference in `epidist`"
description: "..."
output: 
  bookdown::html_document2:
    fig_caption: yes
    code_folding: show
    number_sections: true
pkgdown:
  as_is: true
# csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-numeric-superscript-brackets.csl
link-citations: true
vignette: >
  %\VignetteIndexEntry{Getting started with epidist}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: references.bib
---

```{r setup, include=FALSE}
# exclude compile warnings from cmdstanr
knitr::opts_chunk$set(
  fig.path = "figures/epidist-",
  cache = TRUE,
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE,
  error = FALSE
)
```

# Background

The `epidist` package uses Bayesian inference to estimate delay distributions.
Doing Bayesian inference amounts to approximating the posterior distribution of each model parameter^[See a work-in-progress vignette about the model structure.].

By default, `epidist` uses the No-U-Turn Sampler (NUTS) Hamiltonian Monte Carlo (HMC) algorithm to approximate the posterior distribution.
NUTS works by simulating from a Markov chain which has the posterior distribution as its stationary distribution.
When NUTS is run for sufficiently many iterations, and has "reached convergence", the samples can be considered to be drawn from the posterior distribution, and used to compute relevant posterior quantities such as expectations.
A drawback of NUTS, and other Markov chain Monte Carlo (MCMC) methods, is that they can be quite computational intensive, especially for complex models or large data.

The `epidist` package is built using `brms`, itself built on the Stan probabilistic programming language.
One benefit of this design, is that as other approximate Bayesian inference algorithms are implemented in Stan (and then `brms`), they automatically are available in `epidist`.
As such, if you are using `epidist` and having difficulties using the default NUTS algorithm, you may want to consider an alternative.

In this vignette, we will first briefly describe the alternative algorithms available in Section \@ref(other), as well as directing you to more detailed resources.
Then in Section  \@ref(demo) we demonstrate their application to fitting simulated data, before extracting and comparing posterior distributions.
By comparing the resulting inferences to those from NUTS, to hope to help you make informed decisions about which algorithm to use in your problem.

# Alternative approximate inference algorithms {#other}

Here we describe three alternative approximate Bayesian inference algorithms that are available to use in `epidist`.

## Laplace method

The Laplace method approximates a posterior distribution by a Gaussian distribution.
In Stan, the Gaussian distribution is constructed on the unconstrained parameter space, and samples may then be transformed to the constrained parameter space.
See the section [Laplace Sampling](https://mc-stan.org/docs/cmdstan-guide/laplace_sample_config.html) of the `CmdStan` User's Guide for more information.

## Variational inference using ADVI

Automatic differentiation variational inference [ADVI; @kucukelbir2017advi] is...
See the section [Variational Inference using ADVI](https://mc-stan.org/docs/cmdstan-guide/variational_config.html) of the `CmdStan` User's Guide for more information.

## Pathfinder

Pathfinder is a variational inference method more recently developed by @zhang2022pathfinder.
See the section [Pathfinder Method for Approximate Bayesian Inference](https://mc-stan.org/docs/cmdstan-guide/pathfinder_config.html) of the `CmdStan` User's Guide for more information.

# Demonstration {#demo}

This demonstration requires the following packages:

```{r load-requirements}
library(epidist)
library(ggplot2)
library(dplyr)
```

Simulate data:

```{r}
meanlog <- 1.8
sdlog <- 0.5
obs_time <- 25
sample_size <- 200

obs_cens_trunc <- simulate_gillespie() |>
  simulate_secondary(
    meanlog = meanlog,
    sdlog = sdlog
  ) |>
  observe_process() |>
  filter_obs_by_obs_time(obs_time = obs_time)

obs_cens_trunc_samp <-
  obs_cens_trunc[sample(seq_len(.N), sample_size, replace = FALSE)]
```

Fit the latent individual model using HMC:

```{r results='hide'}
data <- epidist_prepare(obs_cens_trunc_samp, model = "latent_individual")

fit_hmc <- epidist(data = data, algorithm = "sampling")
```

Fit the latent individual model using each method in Section \@ref(other) and draw 4000 samples to match the four Markov chains of 1000 in HMC:

```{r}
fit_laplace <- epidist(data = data, algorithm = "laplace", draws = 4000)
fit_advi <- epidist(data = data, algorithm = "meanfield", draws = 4000)
fit_pathfinder <- epidist(data = data, algorithm = "pathfinder", draws = 4000)
```

Pathfinder runs into the error "Error evaluating model log probability: Non-finite gradient." here.
Strange!
Find a fix.

Extract posterior distribution for the delay parameters:

```{r}
draws_hmc <- extract_lognormal_draws(fit_hmc)
draws_laplace <- extract_lognormal_draws(fit_laplace)
draws_advi <- extract_lognormal_draws(fit_advi)
draws_pathfinder <- extract_lognormal_draws(fit_pathfinder)
```

Compare with a figure or table or both:

```{r}
draws_hmc <- draws_hmc |>
  draws_to_long() |>
  filter(parameter %in% c("mean", "sd")) |>
  mutate(method = "hmc")

draws_laplace <- draws_laplace |>
  draws_to_long() |>
  filter(parameter %in% c("mean", "sd")) |>
  mutate(method = "laplace")

draws_advi <- draws_advi |>
  draws_to_long() |>
  filter(parameter %in% c("mean", "sd")) |>
  mutate(method = "advi")

draws_pathfinder <- draws_pathfinder |>
  draws_to_long() |>
  filter(parameter %in% c("mean", "sd")) |>
  mutate(method = "pathfinder")

fct_reorg <- function(fac, ...) {
  forcats::fct_recode(forcats::fct_relevel(fac, ...), ...)
}

df <- rbind(draws_hmc, draws_laplace, draws_advi) |>
  mutate(
    method = forcats::fct_recode(method,
      "HMC" = "hmc",
      "Laplace" = "laplace",
      "ADVI" = "advi",
      "Pathfinder" = "pathfinder") |>
        forcats::fct_relevel("HMC", "Laplace", "ADVI", "Pathfinder"),
    parameter = forcats::fct_recode(parameter,
      "Mean" = "mean",
      "SD" = "sd"
    )
  )
  
filter(df, parameter == "Mean") |>
  ggplot(aes(x = value)) +
  geom_histogram(aes(y = ..density..)) +
  facet_grid(method ~ parameter) +
  theme_minimal() +
  labs(x = "", y = "")

rbind(df, draws_hmc, draws_laplace, draws_advi) |>
  filter(parameter == "SD") |>
  ggplot(aes(x = value)) +
  geom_histogram(aes(y= ..density..)) +
  facet_grid(method ~ parameter) +
  theme_minimal() +
  labs(x = "", y = "")
```

Compare the time taken:

```{r}
rstan::get_elapsed_time(fit_hmc$fit)
# Remainst to extract from the others
```

## Bibliography {-}
