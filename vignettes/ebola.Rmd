---
title: "Using `epidist` to estimate stratified delays between symptom onset and positive test for the 2014-2016 Ebola outbreak in Sierra Leone"
description: "A more detailed guide to using the `epidist` R package"
output: 
  bookdown::html_document2:
    fig_caption: yes
    code_folding: show
    number_sections: true
pkgdown:
  as_is: true
# csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa-numeric-superscript-brackets.csl
link-citations: true
vignette: >
  %\VignetteIndexEntry{Getting in depth with epidist}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: references.bib
---

```{r setup, include=FALSE}
# exclude compile warnings from cmdstanr
knitr::opts_chunk$set(
  fig.path = "figures/epidist-",
  cache = TRUE,
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE,
  error = FALSE
)
```

The 2014-2016 outbreak of Ebola in West Africa began in Guinea, and quickly spread to neighbouring Liberia and Sierra Leone.
It was the largest outbreak in the disease's history, and resulted in over 28,600 infections and 11,325 deaths [@who_ebola_2014_2016].

In this vignette, we use the `epidist` package to analyze line list data from the outbreak in Sierra Leone.
This data was collated by @fang2016transmission, and is available in the `epidist` package.
In analyzing this data, we demonstrate the following features of `epidist`:

1. Fitting district-sex stratified delay distribution estimates.
2. Fitting models with lognormal and gamma delay distributions.
3. Selecting between fitted models.
4. Post-processing and plotting functionality.

For users new to `epidist`, before reading this article, we recommend beginning with the "[Getting started vignette](http://epidist.epinowcast.org/articles/epidist.html)".

The packages used in this article are:

```{r load-requirements}
library(epidist)
library(data.table)
library(purrr)
library(ggplot2)
library(sf)
library(tidybayes)
library(modelr)
```

# Data preparation

We begin by loading the Ebola line list data.
For more details, see `?sierra_leone_ebola_data`.

```{r}
data("sierra_leone_ebola_data")
```

The data has `r nrow(sierra_leone_ebola_data)` rows, each corresponding to a unique case report `id`.
The columns of the data are the individuals name (retracted, and hence can be removed), age, sex, the dates of symptom onset and positive sample, and their district and chiefdom.

```{r}
sierra_leone_ebola_data <- sierra_leone_ebola_data |>
  dplyr::select(-name) |>
  dplyr::mutate(case = as.integer(id), .keep = "unused")

head(sierra_leone_ebola_data)

fraction <- 10
```

Figure \@ref(fig:ebola-outbreak) shows every `r fraction`th case (to avoid over-plotting the data) by district.
The epidemic begins at different times in different districts.

(ref:ebola-outbreak) Primary and secondary event times for every `r fraction`th case.

```{r ebola-outbreak, fig.cap="(ref:ebola-outbreak)", fig.height=9}
sierra_leone_ebola_data |>
  dplyr::filter(case %% fraction == 0) |>
  ggplot() +
  geom_segment(
    aes(
      x = date_of_symptom_onset, xend = date_of_sample_tested,
      y = case, yend = case
    ),
    col = "grey"
  ) +
  geom_point(aes(x = date_of_symptom_onset, y = case), col = "#56B4E9") +
  geom_point(aes(x = date_of_sample_tested, y = case), col = "#009E73") +
  facet_wrap(district ~ ., ncol = 2) +
  labs(x = "", y = "Case ID") +
  theme_minimal()
```

We can use a map to help visualise the outbreak across space.
To create a map, we first join the Ebola data to shapefiles (obtained from [GADM](https://gadm.org/)) for the districts of Sierra Leone.

```{r message = FALSE}
sf <- sf::st_read("../inst/gadm41_SLE_shp/gadm41_SLE_2.shp")

sierra_leone_ebola_data_sf <- dplyr::select(sf, district = NAME_2, geometry) |>
  dplyr::left_join(
    sierra_leone_ebola_data |>
      dplyr::group_by(district) |>
      dplyr::summarise(cases = dplyr::n())
  )
```

Figure \@ref(fig:ebola-cloropleth) shows that the majority of cases were concentrated in the Western Urban district.

(ref:ebola-cloropleth) A cloropleth showing the total number of Ebola cases in each district of Sierra Leone.

```{r ebola-cloropleth, fig.cap="(ref:ebola-cloropleth)"}
ggplot(sierra_leone_ebola_data_sf, aes(fill = cases, geometry = geometry)) +
  geom_sf() +
  scale_fill_viridis_c(na.value = "lightgrey") +
  theme_minimal() +
  labs(fill = "Cases")
```

# Fitting district-sex stratified delay distributions

## Data preparation

To prepare the data for use in `epidist`, we transform the date columns to `ptime` (time of primary event) and `stime` (time of secondary event) columns.
Both of these columns are given relative to the first date of symptom onset in the data.
We also transform the `data.frame` to a `data.table`.

```{r}
sierra_leone_ebola_data <- sierra_leone_ebola_data |>
  dplyr::mutate(
    date_of_symptom_onset = lubridate::ymd(date_of_symptom_onset),
    date_of_sample_tested = lubridate::ymd(date_of_sample_tested),
    ptime = as.numeric(date_of_symptom_onset - min(date_of_symptom_onset)),
    stime = as.numeric(date_of_sample_tested - min(date_of_symptom_onset))
  ) |>
  dplyr::select(case, ptime, stime, age, sex, district) |>
  data.table::as.data.table()

head(sierra_leone_ebola_data)
```

Next, we use `observe_process()` to do add the required interval censoring columns:

```{r}
obs_cens <- epidist::observe_process(sierra_leone_ebola_data)

all(obs_cens$ptime == obs_cens$ptime_daily)
all(obs_cens$stime == obs_cens$stime_daily)

max(obs_cens$ptime)
max(obs_cens$stime)
```

The columns added are:

* `ptime_daily`: As the `ptime` was already daily then this is superfluous
* `ptime_lwr`: The lower bound on the primary observation time i.e. the floor of `ptime_daily`
* `ptime_upr`: The upper bound on the primary observation time i.e. `ptime_lwr + 1`
* `stime_daily`: As the `ptime` was already daily then this is superfluous
* `stime_lwr`: The lower bound on the secondary observation time i.e. the floor of `stime_daily`
* `stime_upr`: The upper bound on the secondary observation time i.e. `stime_lwr + 1`
* `delay_daily`: Is given by `stime_daily - ptime_daily`
* `delay_lwr`: Is given by `stime_lwr - ptime_upr` i.e. the minimum possible delay
* `delay_upr`: Is given by `stime_upr - ptime_lwr` i.e. the maximum possible delay
* `obs_at`: The maximum value of `stime`

## Model fitting

Now we fit lognormal delay distribution with sex effect and district effect.
First fit model with no district-sex stratification.
Sub-sample the data for speed.
Use ADVI for speed.

```{r}
set.seed(1)

n <- nrow(obs_cens)
obs_cens <- obs_cens[complete.cases(obs_cens)]
n_complete <- nrow(obs_cens)
n_complete / n
obs_cens <- obs_cens[sample(seq_len(.N), n_complete / 5, replace = FALSE)]
obs_prep <- as_latent_individual(obs_cens)

fit <- epidist(
  data = obs_prep,
  formula = brms::bf(mu ~ 1, sigma ~ 1),
  family = brms::lognormal(),
  algorithm = "laplace",
  refresh = 0
)

summary(fit)
```

Fit a model including sex effect:

```{r}
fit_sex <- epidist(
  data = obs_prep,
  formula = brms::bf(mu ~ 1 + sex, sigma ~ 1 + sex),
  family = brms::lognormal(),
  algorithm = "laplace",
  refresh = 0
)

summary(fit_sex)
```

Fit a model including sex effect and district effect:

```{r}
fit_sex_district <- epidist(
  data = obs_prep,
  formula = brms::bf(mu ~ 1 + sex + district, sigma ~ 1 + sex + district),
  family = brms::lognormal(),
  algorithm = "laplace",
  refresh = 0
)

summary(fit_sex_district)
```

## Posterior expectations

To obtain the posterior expectation of the delay distribution, under no censoring or truncation, we may use the `modelr::data_grid` function in combination with the `tidybayes::add_epred_draws` function.
The `tidybayes::add_epred_draws` function uses the `posterior_epred_latent_lognormal` function implemented in `epidist` for the `latent_lognormal` custom `brms` family.

First, for the model with no stratification (Figure \@ref(fig:epred-base)):

```{r}
epred_draws <- obs_prep |>
  as.data.frame() |>
  modelr::data_grid(NA) |>
  dplyr::mutate(obs_t = NA, pwindow_upr = NA, swindow_upr = NA) |>
  add_epred_draws(fit, dpar = TRUE)
```

(ref:epred-base) The fitted posterior expectation of the delay distribution for a model with no stratification.

```{r epred-base, fig.cap="(ref:epred-base)"}
epred_draws |>
  ggplot(aes(x = .epred)) +
  tidybayes::stat_slab() +
  labs(x = "Posterior expectation of the delay", y = "") +
  theme_minimal()
```

Next, for the sex stratified model, we find the men typically have a higher posterior delay expectation than women (Figure \@ref(fig:epred-sex)):

```{r}
# Probably want functionality for users not to have to do this themselves
(newdata_sex <- obs_prep |>
   as.data.frame() |>
   modelr::data_grid(sex) |>
   dplyr::mutate(obs_t = NA, pwindow_upr = NA, swindow_upr = NA))

epred_draws_sex <- tidybayes::add_epred_draws(newdata_sex, fit_sex, dpar = TRUE)
```

(ref:epred-sex) The fitted posterior expectation of the delay distribution for a model with sex stratification.

```{r epred-sex, fig.cap="(ref:epred-sex)"}
epred_draws_sex |>
  dplyr::mutate(
    sex = dplyr::case_when(
      sex == "F" ~ "Female",
      sex == "M" ~ "Male"
    )
  ) |>
  ggplot(aes(x = .epred, y = sex)) +
  tidybayes::stat_halfeye() +
  labs(x = "Posterior expectation of the delay", y = "") +
  theme_minimal()
```

Finally, for the sex-district stratified model:

```{r}
epred_draws_sex_district <- obs_prep |>
  as.data.frame() |>
  modelr::data_grid(sex, district) |>
  dplyr::mutate(obs_t = NA, pwindow_upr = NA, swindow_upr = NA) |>
  add_epred_draws(fit_sex_district, dpar = TRUE)

epred_draws_sex_district |>
  dplyr::mutate(
    sex = dplyr::case_when(
      sex == "F" ~ "Female",
      sex == "M" ~ "Male"
    )
  ) |>
  ggplot(aes(x = .epred, y = district)) +
  tidybayes::stat_pointinterval() +
  facet_grid(. ~ sex) +
  labs(x = "Posterior expectation of the delay", y = "") +
  theme_minimal()

# Some strata that don't have much data? Some very bad priors?
summary(epred_draws_sex_district$.epred)

epred_draws_sex_district |>
  dplyr::group_by(district) |>
  dplyr::summarise(q90 = quantile(.epred, 0.9)) |>
  ggplot(aes(x = district, y = q90)) +
    geom_point()

obs_prep$district |>
  table()
```

## Linear predictor posteriors

```{r}
linpred_draws_sex_district <- obs_prep |>
  as.data.frame() |>
  modelr::data_grid(sex, district) |>
  dplyr::mutate(obs_t = NA, pwindow_upr = NA, swindow_upr = NA) |>
  add_linpred_draws(fit_sex_district, dpar = TRUE)
```

Linear predictors for the `mu` parameter by sex and district:

```{r}
linpred_draws_sex_district |>
  dplyr::mutate(
    sex = dplyr::case_when(
      sex == "F" ~ "Female",
      sex == "M" ~ "Male"
    )
  ) |>
  ggplot(aes(x = mu, y = district)) +
  tidybayes::stat_pointinterval() +
  facet_grid(. ~ sex) +
  labs(x = "Posterior of the mu linear predictor", y = "") +
  theme_minimal()
```

Linear predictors for the `sigma` parameter by sex and district:

```{r}
linpred_draws_sex_district |>
  dplyr::mutate(
    sex = dplyr::case_when(
      sex == "F" ~ "Female",
      sex == "M" ~ "Male"
    )
  ) |>
  ggplot(aes(x = sigma, y = district)) +
  tidybayes::stat_pointinterval() +
  facet_grid(. ~ sex) +
  labs(x = "Posterior of the sigma linear predictor", y = "") +
  theme_minimal()
```

## Posterior predictions

Posterior prediction of the observed data.
(One sample from it.)

```{r}
draws <- predicted_draws(fit, newdata = as.data.frame(obs_prep))

# This is just a single draw. To get many draws do you have to repeat rows?
draws$.draw |> summary()

ggplot(draws, aes(x = .prediction, y = district)) +
  tidybayes::stat_pointinterval() +
  facet_grid(. ~ sex) +
  theme_minimal()
```

How does this `rvars` stuff work?

```{r}
obs_prep |>
  as.data.frame() |>
  add_predicted_rvars(fit) |>
  dplyr::select(.prediction) |>
  head()
```

## Delay probability mass functions

Do a posterior predictive distribution under no truncation but daily censoring.
Then plot those as discrete PMF.

```{r}
newdata_pmf <- obs_prep |>
  as.data.frame() |>
  modelr::data_grid(rep = seq_along(1:5000)) |>
  dplyr::mutate(obs_t = 1000, pwindow_upr = 1, swindow_upr = 1)

# Anything here with the prediction being vectorised?
# Would that solve my draws only being one issue?
draws_pmf <- predicted_draws(fit, newdata = newdata_pmf, ndraws = 1)

ggplot(draws_pmf, aes(x = .prediction)) +
  geom_bar(aes(y = after_stat(count / sum(count)))) +
  labs(x = "PMF with daily censoring and no truncation", y = "") +
  theme_minimal()
```

What about the "continuous" no truncation no censoring distribution?

```{r}
newdata_pdf <- obs_prep |>
  as.data.frame() |>
  modelr::data_grid(rep = seq_along(1:5000)) |>
  dplyr::mutate(obs_t = 1000, pwindow_upr = 0.001, swindow_upr = 0.001)

draws_pdf <- predicted_draws(fit, newdata = newdata_pdf, ndraws = 1)

# I don't like that this is also doing kernel smoothing (to some extent)
# But plotting as a histogram is suggestive of there being discrete structure
ggplot(draws_pdf, aes(x = .prediction)) +
  geom_density() +
  labs(x = "PDF with no censoring and no truncation", y = "") +
  theme_minimal()
```

## Model comparison

* Is it worth including sex as a covariate? 
* Is it worth including district as a covariate? What about spatially structured?

# Using a gamma delay distribution

## Fitting 

* Just fit the best model from above here?
* Going to do the sex stratified one for now

```{r}
fit_sex_gamma <- epidist(
  data = obs_prep,
  formula = brms::bf(mu ~ 1 + sex, shape ~ 1 + sex),
  family = stats::Gamma(),
  algorithm = "laplace",
  refresh = 0
)

summary(fit_sex_gamma)
```

# Model selection

* Should we use the lognormal or gamma delay distribution?

# Conclusion

## Bibliography {-}
